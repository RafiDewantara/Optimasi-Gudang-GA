# -*- coding: utf-8 -*-
"""tubesAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gE14aRaLBLZZpe4h4SQ1Fr_yND-VgDLp

**IMPORT LIBRARY**
"""

import numpy as np
import pandas as pd
import random
import matplotlib.pyplot as plt

random.seed(42)
np.random.seed(42)

"""**UPLOAD DATASET**"""

csv_path = "/content/Retail and wherehouse Sale.csv"
df = pd.read_csv(csv_path)

print("Shape:", df.shape)
display(df.head())
print(df.columns)

"""**Preprocessing: Demand per Item**"""

for col in ["RETAIL SALES", "RETAIL TRANSFERS", "WAREHOUSE SALES"]:
    df[col] = pd.to_numeric(df[col], errors="coerce").fillna(0)

demand = df.groupby("ITEM CODE")["WAREHOUSE SALES"].sum()

item_desc = df.groupby("ITEM CODE")["ITEM DESCRIPTION"].agg(lambda x: x.mode().iloc[0] if len(x.mode()) else x.iloc[0])

demand_df = pd.DataFrame({
    "ITEM CODE": demand.index,
    "DEMAND": demand.values,
    "DESC": item_desc.reindex(demand.index).values
}).sort_values("DEMAND", ascending=False)

display(demand_df.head(10))
print("Total unique items:", demand_df.shape[0])

"""**Ambil Top-N Item**"""

TOP_N = 60
items = demand_df.head(TOP_N).reset_index(drop=True)

item_codes = items["ITEM CODE"].tolist()
item_demands = items["DEMAND"].to_numpy(dtype=float)
item_names = items["DESC"].tolist()

print("N items:", len(item_codes))
display(items.head(10))

"""**Definisi Gudang (Grid) + Jarak ke Depot**


"""

ROWS, COLS = 10, 10
NUM_SLOTS = ROWS * COLS

assert NUM_SLOTS >= TOP_N, "Slot gudang kurang! Naikkan ROWS/COLS atau turunkan TOP_N."

depot = (0, 0)

slot_coords = [(r, c) for r in range(ROWS) for c in range(COLS)]

def manhattan(a, b):
    return abs(a[0]-b[0]) + abs(a[1]-b[1])

slot_dist = np.array([manhattan(coord, depot) for coord in slot_coords], dtype=float)

slots_sorted = np.argsort(slot_dist)
slot_dist_sorted = slot_dist[slots_sorted]

print("Contoh 10 slot terdekat (index_original, coord, dist):")
for k in range(10):
    idx = slots_sorted[k]
    print(k, idx, slot_coords[idx], slot_dist[idx])

"""**Representasi Gudang & GA State**


"""

def decode_chromosome(chromosome):
    """
    chromosome: list of item indices (0..TOP_N-1) in placement order
    Return mapping item_index -> slot_index_original
    """
    mapping = {}
    for gene_pos, item_idx in enumerate(chromosome):
        slot_original_index = slots_sorted[gene_pos]  # slot terdekat untuk posisi gene_pos
        mapping[item_idx] = slot_original_index
    return mapping

demo = list(range(min(10, TOP_N)))
random.shuffle(demo)
mapping_demo = decode_chromosome(demo)

print("DEMO CHROMOSOME (item_idx order):", demo)
print("\nMakna (gene_pos -> slot_terdekat_ke-pos):")
for pos, item_idx in enumerate(demo[:10]):
    slot_idx = slots_sorted[pos]
    print(f"gene_pos {pos}: item {item_idx} ({item_codes[item_idx]}) -> slot {slot_idx} coord {slot_coords[slot_idx]} dist {slot_dist[slot_idx]}")

"""**Inisialisasi Populasi (Generasi Pertama)**"""

POP_SIZE = 80

def init_population(pop_size, n_items):
    population = []
    base = list(range(n_items))
    for _ in range(pop_size):
        chrom = base.copy()
        random.shuffle(chrom)
        population.append(chrom)
    return population

population = init_population(POP_SIZE, TOP_N)
print("Population size:", len(population))
print("Sample chromosome:", population[0][:15], "...")

"""**Fitness Function**"""

def cost_of(chromosome):
    chrom = np.array(chromosome, dtype=int)
    demands_in_order = item_demands[chrom]
    return float(np.sum(demands_in_order * slot_dist_sorted[:TOP_N]))

def fitness_of(chromosome, eps=1e-9):
    c = cost_of(chromosome)
    return 1.0 / (c + eps)

c0 = cost_of(population[0])
f0 = fitness_of(population[0])
print("Sample cost:", c0)
print("Sample fitness:", f0)

"""**Roulette Wheel Selection + Visualisasi “Garis Bilangan”**"""

def roulette_wheel_select(population, fitnesses, n_select=2, debug_plot=False, show_top=12):
    """
    Roulette wheel selection:
    - Seleksi berdasarkan probabilitas proporsional fitness
    - debug_plot=True menampilkan:
        (1) roulette wheel (pie chart)
        (2) garis bilangan [0..1] + batas kumulatif + titik spin

    show_top: untuk pie chart agar tidak terlalu rame (top-k + Others)
    Seleksi tetap memakai semua individu.
    """
    fit = np.array(fitnesses, dtype=float)

    if np.all(fit <= 0) or fit.sum() == 0:
        selected = [random.choice(population) for _ in range(n_select)]
        return selected, None, None, None

    probs = fit / fit.sum()
    cum = np.cumsum(probs)

    selected = []
    spins = []

    for _ in range(n_select):
        r = random.random()
        idx = int(np.searchsorted(cum, r, side="left"))
        selected.append(population[idx])
        spins.append((r, idx))

    if debug_plot:
        fig, axes = plt.subplots(2, 1, figsize=(12, 9))

        top_idx = np.argsort(probs)[::-1][:show_top]
        top_probs = probs[top_idx]
        top_labels = [f"Ind {i+1}\n{(top_probs[k]*100):.1f}%" for k, i in enumerate(top_idx)]

        rest_prob = 1.0 - top_probs.sum()
        pie_probs = list(top_probs) + ([rest_prob] if rest_prob > 1e-12 else [])
        pie_labels = top_labels + (["Others"] if rest_prob > 1e-12 else [])

        axes[0].pie(
            pie_probs,
            labels=pie_labels,
            startangle=90,
            counterclock=False
        )
        axes[0].set_title(
            "Roulette Wheel Selection (Pie Chart)\n"
            f"(Visual top {show_top}; seleksi tetap memakai semua individu)"
        )

        axes[1].hlines(0, 0, 1, linewidth=2)
        axes[1].set_xlim(0, 1)
        axes[1].set_ylim(-0.6, 0.9)
        axes[1].set_yticks([])
        axes[1].set_xlabel("Probabilitas Kumulatif")
        axes[1].set_title("Garis Bilangan [0..1] + batas kumulatif + titik spin")

        step = max(1, len(cum)//40)
        for i in range(0, len(cum), step):
            x = cum[i]
            axes[1].vlines(x, -0.2, 0.2, alpha=0.85)

        for r, idx in spins:
            axes[1].scatter([r], [0], s=140)
            axes[1].text(r, 0.35, f"spin={r:.3f}\nambil Ind {idx+1}", ha="center")

        plt.tight_layout()
        plt.show()

    return selected, probs, cum, spins

fitnesses = [fitness_of(ch) for ch in population]
parents, probs, cum, spins = roulette_wheel_select(population, fitnesses, n_select=2, debug_plot=True, show_top=12)
print("Spin result:", spins)

"""**Crossover**"""

def order_crossover(parent1, parent2):
    n = len(parent1)
    a, b = sorted(random.sample(range(n), 2))

    child = [-1]*n
    child[a:b+1] = parent1[a:b+1]

    p2_seq = [x for x in parent2 if x not in child]
    idx = 0
    for i in range(n):
        if child[i] == -1:
            child[i] = p2_seq[idx]
            idx += 1

    return child

p1, p2 = population[0], population[1]
child = order_crossover(p1, p2)
print("Parent1 head:", p1[:10])
print("Parent2 head:", p2[:10])
print("Child head  :", child[:10])
print("Valid permutation?", len(set(child)) == TOP_N)

"""**Mutasi (Swap Mutation)**"""

def swap_mutation(chromosome, mutation_rate=0.2):
    chrom = chromosome.copy()
    if random.random() < mutation_rate:
        i, j = random.sample(range(len(chrom)), 2)
        chrom[i], chrom[j] = chrom[j], chrom[i]
    return chrom

mut = swap_mutation(population[0], mutation_rate=1.0)
print("Before:", population[0][:12])
print("After :", mut[:12])

"""**GA Loop (Seleksi → Crossover → Mutasi → Hitung Fitness Lagi)**

"""

GENERATIONS = 200
POP_SIZE = 80
CROSSOVER_RATE = 0.9
MUTATION_RATE = 0.2
ELITISM = 2

best_history = []
avg_history = []

population = init_population(POP_SIZE, TOP_N)

for gen in range(GENERATIONS):
    fitnesses = [fitness_of(ch) for ch in population]
    costs = [cost_of(ch) for ch in population]

    best_cost = float(np.min(costs))
    avg_cost = float(np.mean(costs))
    best_history.append(best_cost)
    avg_history.append(avg_cost)

    elite_idx = np.argsort(costs)[:ELITISM]
    elites = [population[i] for i in elite_idx]

    new_pop = elites.copy()

    while len(new_pop) < POP_SIZE:
        parents, _, _, _ = roulette_wheel_select(
            population, fitnesses,
            n_select=2,
            debug_plot=False
        )
        p1, p2 = parents

        if random.random() < CROSSOVER_RATE:
            c1 = order_crossover(p1, p2)
            c2 = order_crossover(p2, p1)
        else:
            c1, c2 = p1.copy(), p2.copy()

        c1 = swap_mutation(c1, mutation_rate=MUTATION_RATE)
        c2 = swap_mutation(c2, mutation_rate=MUTATION_RATE)

        new_pop.append(c1)
        if len(new_pop) < POP_SIZE:
            new_pop.append(c2)

    population = new_pop

    if (gen + 1) % 20 == 0:
        print(f"Gen {gen+1:3d} | Best Cost: {best_cost:,.2f} | Avg Cost: {avg_cost:,.2f}")

print("Selesai.")

"""**Plot Konvergensi (Best Cost vs Generasi)**"""

plt.figure(figsize=(8,4))
plt.plot(best_history)
plt.title("Konvergensi GA: Best Cost per Generasi")
plt.xlabel("Generasi")
plt.ylabel("Best Cost (Σ demand × jarak)")
plt.grid(True)
plt.show()

"""**Ambil Solusi Terbaik + Tampilkan Mapping Item → Slot**"""

costs = [cost_of(ch) for ch in population]
best_idx = int(np.argmin(costs))
best_chrom = population[best_idx]
best_cost = costs[best_idx]

print("BEST COST:", best_cost)

mapping = decode_chromosome(best_chrom)

rows = []
for item_idx, slot_idx in mapping.items():
    rows.append({
        "ITEM CODE": item_codes[item_idx],
        "DESC": item_names[item_idx],
        "DEMAND": item_demands[item_idx],
        "SLOT_IDX": slot_idx,
        "COORD": slot_coords[slot_idx],
        "DIST": slot_dist[slot_idx],
    })

result_df = pd.DataFrame(rows).sort_values("DIST").reset_index(drop=True)
display(result_df.head(20))

"""**Visualisasi Tata Letak Gudang (Grid)**"""

grid = np.full((ROWS, COLS), fill_value=-1, dtype=int)

for item_idx, slot_idx in mapping.items():
    r, c = slot_coords[slot_idx]
    grid[r, c] = item_idx

plt.figure(figsize=(7,7))
plt.imshow(grid, interpolation="nearest")
plt.title("Visualisasi Layout Gudang (setiap sel berisi item_idx)")

for r in range(ROWS):
    for c in range(COLS):
        if grid[r, c] != -1:
            plt.text(c, r, str(grid[r, c]), ha="center", va="center", fontsize=8)

plt.scatter([depot[1]], [depot[0]], s=200, marker="X")
plt.text(depot[1], depot[0]-0.6, "DEPOT", ha="center", va="center", fontsize=10)

plt.xticks(range(COLS))
plt.yticks(range(ROWS))
plt.grid(True, which="both")
plt.show()

fitnesses = [fitness_of(ch) for ch in population]
parents, probs, cum, spins = roulette_wheel_select(
    population,
    fitnesses,
    n_select=2,
    debug_plot=True,
    show_top=12
)

print("Hasil spin (r, idx_individu_terpilih):", spins)